//=============================================================================
//
// 着地点処理 [boundPoint.cpp]
// Author : 呉優
//
//=============================================================================

//*****************************************************************************
// インクルードファイル
//*****************************************************************************
#include "boundPoint.h"
#include "ball.h"
#include "field.h"
#include "block.h"
#include "bar.h"

//*****************************************************************************
// マクロ定義
//*****************************************************************************

//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************

//*****************************************************************************
// グローバル変数
//*****************************************************************************
BOUNDPOINT g_BoundPoint;

//=============================================================================
// 着地点の初期化処理
//=============================================================================
void InitBoundPoint(void) {
	g_BoundPoint.x = 0;
	g_BoundPoint.y = FIELD_H - BAR_H - BAR_FLOAT - 1;	// -1しているのは、床の分
	g_BoundPoint.use = 0;

}

//=============================================================================
// 着地点の終了処理
//=============================================================================
void UninitBoundPoint(void) {

}

//=============================================================================
// 着地点の更新処理
//=============================================================================
void UpdateBoundPoint(void) {

}

//=============================================================================
// 着地点の描画処理
//=============================================================================
void DrawBoundPoint(void) {
	// 有効な時だけ描画
	if (g_BoundPoint.use) {
		SetField(g_BoundPoint.x, g_BoundPoint.y, BOUNDPOINT_DATA);
	}
}

//=============================================================================
// 着地点の取得
//=============================================================================
BOUNDPOINT* GetBoundPoint(void) {
	return &g_BoundPoint;
}

//=============================================================================
// 着地点の制御
//=============================================================================
void CreateBoundPoint(void) {

	///////////////////////////////////////////////////////////////////////////
	// ボールの座標と進行方向を取得
	///////////////////////////////////////////////////////////////////////////
	// 一部取得
	BALL* ball = GetBall();
	int ver_y = ball->ver_y;

	// ボールが下へ向かっていない場合、無効化して終了
	if (ver_y < 0) {
		g_BoundPoint.use = FALSE;
		return;
	}

	// 残りを取得
	int x = ball->x;
	int y = ball->y;
	int ver_x = ball->ver_x;

	///////////////////////////////////////////////////////////////////////////
	// 着地点判定
	///////////////////////////////////////////////////////////////////////////
	while (1) {
		// オーバーフロー防止
		if (x * y <= 0 ||	// x,yのどちらか0より小さくなった場合
			x >= FIELD_W - 1 ||
			y >= FIELD_H - 1) {
			return;
		}

		// ボールの進行軌跡を取得
		char field = GetField(x, y);

		// 途中でブロックに当たる場合、無効化して終了
		if (field == BLOCK_DATA) {
			g_BoundPoint.use = FALSE;
			return;
		}

		// 途中で壁に当たる場合、方向転換して続行
		if (field == WALL_DATA) {
			// 一歩戻す
			x -= ver_x;
			y -= ver_y;

			// 方向転換
			ver_x = -ver_x;
		}

		// 着地点の高さまで来た場合、脱出
		if (y == g_BoundPoint.y) {
			g_BoundPoint.use = TRUE;
			break;
		}
		x += ver_x;
		y += ver_y;
	}
	// バウンド地点にマークを生成
	g_BoundPoint.x = x;
}